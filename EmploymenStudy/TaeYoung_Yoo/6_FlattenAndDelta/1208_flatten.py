# flatten 문제 풀기
# 한 쪽 벽면에 다음과 같이 노란색 상자들이 쌓여 있다.
#
# 높은 곳의 상자를 낮은 곳에 옮기는 방식으로 최고점과 최저점의 간격을 줄이는 작업을 평탄화라고 한다.
#
# 평탄화를 모두 수행하고 나면, 가장 높은 곳과 가장 낮은 곳의 차이가 최대 1 이내가 된다.
#
# 평탄화 작업을 위해서 상자를 옮기는 작업 횟수에 제한이 걸려있을 때, 제한된 횟수만큼 옮기는 작업을 한 후 최고점과 최저점의 차이를 반환하는 프로그램을 작성하시오.
# A’부분의 상자를 옮겨서, C부분에 덤프하였다. 이때 C 대신 C’부분에 덤프해도 무방하다.
#
# 2회의 덤프 후, 최고점과 최저점의 차이는 8 – 2 = 6 이 되었다 (최초덤프 이전에는 9 – 1 = 8 이었다).
#
# 덤프 횟수가 2회로 제한된다면, 이 예시 문제의 정답은 6이 된다.
#
# [제약 사항]
#
# 가로 길이는 항상 100으로 주어진다.
#
# 모든 위치에서 상자의 높이는 1이상 100이하로 주어진다.
#
# 덤프 횟수는 1이상 1000이하로 주어진다.
#
# 주어진 덤프 횟수 이내에 평탄화가 완료되면 더 이상 덤프를 수행할 수 없으므로 그 때의 최고점과 최저점의 높이 차를 반환한다 (주어진 data에 따라 0 또는 1이 된다).
#
# [입력]
#
# 총 10개의 테스트 케이스가 주어지며, 각 테스트 케이스의 첫 번째 줄에는 덤프 횟수가 주어진다. 그리고 다음 줄에 각 상자의 높이값이 주어진다.
#
# [출력]
#
# #부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스의 최고점과 최저점의 높이 차를 출력한다.

def Flatten(arr, dump_count):
    # dump가 0이 될때까지 돈다.
    while dump_count > 0:
        # 만약 arr에 가장 큰 값과 가장 낮은 값의 높이같으면 0반환
        max_idx = -1
        min_idx = -1
        if max(arr) == min(arr):
            return 0
        else:
            # 만약 차이가 존재하고 dump_count가 0이 아니라면
            # 가장 큰값에서 하나 빼주고 가장 낮은 값에 하나 더해줌
            # 그리고 dump_count를 하나 줄여서 다시 실행
            for idx in range(len(arr)):
                if arr[idx] == max(arr):
                    max_idx = idx
                elif arr[idx] == min(arr):
                    min_idx = idx
                # 최대, 최소 값을 찾았으면 break로 깨고
                # dump_count -= 1 해줘야함
                # 안그러면 for문 초기화 안되고 돌아서 문제발생
                if max_idx >= 0 and min_idx >= 0:
                    arr[max_idx] -= 1
                    arr[min_idx] += 1
                    break

        dump_count -= 1

    return max(arr) - min(arr)


T = 10 # 10개의 테스트 케이스 주어짐
for test_case in range(1, T+1):
    dump_count = int(input())
    arr = list(map(int, input().split()))

    print(f'#{test_case} {Flatten(arr, dump_count)}')




